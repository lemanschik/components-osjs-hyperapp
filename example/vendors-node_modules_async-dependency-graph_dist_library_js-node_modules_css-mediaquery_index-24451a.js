(self['webpackChunk_osjs_osjs'] = self['webpackChunk_osjs_osjs'] || []).push([['vendors-node_modules_async-dependency-graph_dist_library_js-node_modules_css-mediaquery_index-24451a'], {

  /***/ '../node_modules/async-dependency-graph/dist/graph.js':
  /* !************************************************************!*\
  !*** ../node_modules/async-dependency-graph/dist/graph.js ***!
  \************************************************************/
  /***/ ((__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', ({value: true}));
    exports.Node = exports.Graph = void 0;
    const mutex_1 = __webpack_require__(/* ! ./mutex */ '../node_modules/async-dependency-graph/dist/mutex.js');
    /**
   * Base dependency graph class.
   */
    const Graph /** @class */ = (() => {
      class Graph {
        constructor() {
          this.nodes = {};
          this.outgoingEdges = {};
          this.incomingEdges = {};
        }

        /**
       * Add a node to the graph.
       * @param node Node object.
       */
        addNode(node) {
          if (this.hasNode(node.name)) {
            throw new Error(`A node with the name of "${node.name}" already exists in the graph!`);
          }
          this.nodes[node.name] = node;
          this.outgoingEdges[node.name] = [];
          this.incomingEdges[node.name] = [];
        }

        /**
       * Remove a node by name from the graph.
       * @param name Node name.
       */
        removeNode(name) {
          if (!this.hasNode(name)) {
            throw new Error(`A node with the name of "${name}" does not exist in the graph!`);
          }
          delete this.nodes[name];
          delete this.outgoingEdges[name];
          delete this.incomingEdges[name];
          for (const dependent in this.incomingEdges) {
            if (this.incomingEdges[dependent].includes(name)) {
              this.incomingEdges[dependent].splice(dependent.indexOf(name), 1);
            }
          }
          for (const dependency in this.outgoingEdges) {
            if (this.outgoingEdges[dependency].includes(name)) {
              this.outgoingEdges[dependency].splice(dependency.indexOf(name), 1);
            }
          }
        }

        /**
       * Checks to see if the graph contains a Node by name.
       * @param name Node name.
       */
        hasNode(name) {
          return this.nodes.hasOwnProperty(name);
        }

        /**
       * Returns the number of nodes in a graph.
       */
        get size() {
          return Object.keys(this.nodes).length;
        }

        /**
       * Returns the Node instance given a node name.
       * @param name Node name.
       */
        getNode(name) {
          if (this.hasNode(name)) {
            return this.nodes[name];
          }
          throw new Error(`Node "${name}" not found!`);
        }

        /**
       *  Adds a node dependence. "from" is dependent on "to"
       *  @param from Node name.
       *  @param to  Node name.
       */
        addDependency(from, to) {
          if (!this.hasNode(from)) {
            throw new Error(`Node does not exist: ${from}`);
          }
          if (!this.hasNode(to)) {
            throw new Error(`Node does not exist: ${to}`);
          }
          if (from === to) {
            throw new Error(`Cannot add self dependency: ${to}`);
          }
          if (!this.outgoingEdges[from].includes(to)) {
            this.outgoingEdges[from].push(to);
          }
          if (!this.incomingEdges[to].includes(from)) {
            this.incomingEdges[to].push(from);
          }
        }

        /**
       * Removes a node dependence. "from" is no longer dependent on "to".
       * @param from Node name.
       * @param to  Node name.
       * @todo Test this function.
       */
        removeDependency(from, to) {
          console.warn('removeDependency() has not been tested.');
          if (!this.hasNode(from)) {
            throw new Error(`Node does not exist: ${from}`);
          }
          if (!this.hasNode(to)) {
            throw new Error(`Node does not exist: ${to}`);
          }
          if (from === to) {
            throw new Error(`Cannot remove self dependency: ${to}`);
          }
          if (!this.outgoingEdges[from].includes(to)) {
            this.outgoingEdges[from].splice(this.outgoingEdges[from].indexOf(to), 1);
          }
          if (!this.incomingEdges[to].includes(from)) {
            this.incomingEdges[to].splice(this.incomingEdges[to].indexOf(to), 1);
          }
        }

        /**
       * Get dependency node names for a Node by name. (Required nodes for this node to execute).
       * @param name Node name.
       */
        dependenciesOf(name) {
          return this.outgoingEdges[name];
        }

        /**
       * Get dependents node names for a Node by name. (Nodes that require this node to complete).
       * @param name Node name.
       */
        dependentsOf(name) {
          return this.incomingEdges[name];
        }

        /**
       * Breadth first search.
       */
        traverse() {
          const _this = this;
          // Clear all complete node mutexes.
          Object.keys(this.nodes).map(name => {
            return _this.getNode(name).clearMutex();
          });
          // Visiting a node recursively calls visit on each node's dependents.
          const visit = node => {
            // First await all dependencies
            return Promise.all(_this.dependenciesOf(node.name).map(dependencyName => {
              return _this.nodes[dependencyName].awaitData();
            }))
              .then(() => {
                node.signalDependenciesReady();
                if (_this.dependentsOf(node.name).length > 0) {
                  // Then recursively visit all dependents
                  return Promise.all(_this.dependentsOf(node.name).map(dependentName => {
                    return visit(_this.getNode(dependentName));
                  }));
                } else {
                  // node has no dependents so await data
                  return node.awaitData();
                }
              });
          };
          // Find nodes with no dependencies
          const rootNodeNames = Object.keys(this.nodes).filter(name => {
            return _this.dependenciesOf(name).length === 0;
          });
          if (rootNodeNames.length === 0 && Object.keys(this.nodes).length > 0) {
            return Promise.reject(new Error('The graph is circular. Cannot traverse graph due to no root node.'));
          }
          // Start recursive traversal from root nodes.
          return Promise.all(rootNodeNames.map(name => {
            return visit(_this.nodes[name]);
          }));
        }

        /**
       * Clears the value of a node and the values of dependent nodes
       * @param name Node name.
       */
        clearNodeAndDependents(name) {
          const _this = this;
          const node = this.getNode(name);
          const visitAndClear = node => {
            if (node.hasData()) {
              node.clearData();
              return Promise.all(_this.dependentsOf(node.name).map(dependentName => {
                return visitAndClear(_this.getNode(dependentName));
              }));
            } else {
              return Promise.resolve();
            }
          };
          return visitAndClear(node);
        }

        /**
       * Resets the graph by resetting each node in the graph.
       */
        reset() {
          for (const name in this.nodes) {
            this.nodes[name].reset();
          }
        }

        /**
       * Prints graph nodes and node dependents.
       */
        ls() {
          for (let name in this.nodes) {
            console.log(name);
            console.log(this.dependentsOf(name));
          }
        }
      }

      return Graph;
    })();
    exports.Graph = Graph;
    const Node /** @class */ = (() => {
      class Node {
        constructor(name, promise) {
          this.locked = false;
          this._name = name;
          this._promise = promise;
        }

        get name() {
          return this._name;
        }

        /**
       * Await data.
       * @returns A `Promise<T | null>` that resolves when the node's data is ready.
       */
        awaitData() {
          const _this = this;
          if (!this.mutex) {
            this.mutex = new mutex_1.Mutex(() => {
              return _this._data !== undefined;
            });
          }
          return new Promise((resolve, reject) => {
            _this.mutex.await(error => {
              if (error) {
                return reject(error);
              }
              resolve(_this._data);
            });
          });
        }

        signalDependenciesReady() {
          const _this = this;
          if (!this.mutex) {
            this.mutex = new mutex_1.Mutex(() => {
              return _this._data !== undefined;
            });
          }
          if (this._data === undefined) {
            // Only allow to _promise once
            if (this.locked === true) {
              return;
            }
            this.locked = true;
            const promise = this._promise();
            if (promise === undefined) {
              throw new Error(`Node "${this._name}" has undefined promise.`);
            }
            promise.then(data => {
              _this._data = data;
              _this.locked = false;
              _this.mutex.ready();
            }).catch(error => {
              _this._data = null;
              _this.locked = false;
              _this.mutex.ready(error);
            });
          } else {
            // Allow _data to be set externally from promise
            this.mutex.ready();
          }
        }

        setData(data) {
          this._data = data;
          this.signalDependenciesReady();
        }

        /**
       * Resets node. Clears all node data and resets its mutex.
       */
        reset() {
          this.clearData();
          this.clearMutex();
        }

        clearMutex() {
          if (this.hasData()) {
            this.mutex = undefined;
          }
        }

        hasData() {
          return this._data !== undefined;
        }

        clearData() {
          this._data = undefined;
        }
      }

      return Node;
    })();
    exports.Node = Node;


  /***/
  }),

  /***/ '../node_modules/async-dependency-graph/dist/library.js':
  /* !**************************************************************!*\
  !*** ../node_modules/async-dependency-graph/dist/library.js ***!
  \**************************************************************/
  /***/ (function(__unused_webpack_module, exports, __webpack_require__) {
    const __createBinding = (this && this.__createBinding) || (Object.create ? ((o, m, k, k2) => {
      if (k2 === undefined) {
        k2 = k;
      }
      Object.defineProperty(o, k2, {enumerable: true, get() {
        return m[k];
      }});
    }) : ((o, m, k, k2) => {
      if (k2 === undefined) {
        k2 = k;
      }
      o[k2] = m[k];
    }));
    const __exportStar = (this && this.__exportStar) || ((m, exports) => {
      for (const p in m) {
        if (p !== 'default' && !Object.prototype.hasOwnProperty.call(exports, p)) {
          __createBinding(exports, m, p);
        }
      }
    });
    Object.defineProperty(exports, '__esModule', ({value: true}));
    __exportStar(__webpack_require__(/* ! ./graph */ '../node_modules/async-dependency-graph/dist/graph.js'), exports);


  /***/
  }),

  /***/ '../node_modules/async-dependency-graph/dist/mutex.js':
  /* !************************************************************!*\
  !*** ../node_modules/async-dependency-graph/dist/mutex.js ***!
  \************************************************************/
  /***/ ((__unused_webpack_module, exports) => {
    Object.defineProperty(exports, '__esModule', ({value: true}));
    exports.Mutex = void 0;
    const Mutex /** @class */ = (() => {
      class Mutex {
        constructor(readyTest) {
          this.readyTest = readyTest;
        }

        await(callback) {
          if (this.readyTest() === true) {
            callback();
          } else {
            this.waiting = this.waiting || [];
            this.waiting.push(callback);
          }
        }

        // called when we know what we are waiting for is ready
        ready(error) {
          if (this.waiting) {
            this.waiting.forEach(callback => {
              return callback(error);
            });
          }
          delete this.waiting;
        }
      }

      return Mutex;
    })();
    exports.Mutex = Mutex;


  /***/
  }),

  /***/ '../node_modules/css-mediaquery/index.js':
  /* !***********************************************!*\
  !*** ../node_modules/css-mediaquery/index.js ***!
  \***********************************************/
  /***/ ((__unused_webpack_module, exports) => {
  /*
  Copyright (c) 2014, Yahoo! Inc. All rights reserved.
  Copyrights licensed under the New BSD License.
  See the accompanying LICENSE file for terms.
  */


    exports.match = matchQuery;
    exports.parse = parseQuery;

    // -----------------------------------------------------------------------------

    const RE_MEDIA_QUERY     = /(?:(only|not)?\s*([^\s\(\)]+)(?:\s*and)?\s*)?(.+)?/i;

    const RE_MQ_EXPRESSION   = /\(\s*([^\s\:\)]+)\s*(?:\:\s*([^\s\)]+))?\s*\)/;
    const RE_MQ_FEATURE      = /^(?:(min|max)-)?(.+)/;
    const RE_LENGTH_UNIT     = /(em|rem|px|cm|mm|in|pt|pc)?$/;
    const RE_RESOLUTION_UNIT = /(dpi|dpcm|dppx)?$/;

    function matchQuery(mediaQuery, values) {
      return parseQuery(mediaQuery).some(query => {
        const inverse = query.inverse;

        // Either the parsed or specified `type` is "all", or the types must be
        // equal for a match.
        const typeMatch = query.type === 'all' || values.type === query.type;

        // Quit early when `type` doesn't match, but take "not" into account.
        if ((typeMatch && inverse) || !(typeMatch || inverse)) {
          return false;
        }

        const expressionsMatch = query.expressions.every(expression => {
          const feature  = expression.feature;
          const modifier = expression.modifier;
          let expValue = expression.value;
          let value    = values[feature];

          // Missing or falsy values don't match.
          if (!value) {
            return false;
          }

          switch (feature) {
          case 'orientation':
          case 'scan':
            return value.toLowerCase() === expValue.toLowerCase();

          case 'width':
          case 'height':
          case 'device-width':
          case 'device-height':
            expValue = toPx(expValue);
            value    = toPx(value);
            break;

          case 'resolution':
            expValue = toDpi(expValue);
            value    = toDpi(value);
            break;

          case 'aspect-ratio':
          case 'device-aspect-ratio':
          case /* Deprecated */ 'device-pixel-ratio':
            expValue = toDecimal(expValue);
            value    = toDecimal(value);
            break;

          case 'grid':
          case 'color':
          case 'color-index':
          case 'monochrome':
            expValue = parseInt(expValue, 10) || 1;
            value    = parseInt(value, 10) || 0;
            break;
          }

          switch (modifier) {
          case 'min': return value >= expValue;
          case 'max': return value <= expValue;
          default   : return value === expValue;
          }
        });

        return (expressionsMatch && !inverse) || (!expressionsMatch && inverse);
      });
    }

    function parseQuery(mediaQuery) {
      return mediaQuery.split(',').map(query => {
        query = query.trim();

        const captures    = query.match(RE_MEDIA_QUERY);
        const modifier    = captures[1];
        const type        = captures[2];
        let expressions = captures[3] || '';
        const parsed      = {};

        parsed.inverse = !!modifier && modifier.toLowerCase() === 'not';
        parsed.type    = type ? type.toLowerCase() : 'all';

        // Split expressions into a list.
        expressions = expressions.match(/\([^\)]+\)/g) || [];

        parsed.expressions = expressions.map(expression => {
          const captures = expression.match(RE_MQ_EXPRESSION);
          const feature  = captures[1].toLowerCase().match(RE_MQ_FEATURE);

          return {
            modifier: feature[1],
            feature : feature[2],
            value   : captures[2]
          };
        });

        return parsed;
      });
    }

    // -- Utilities ----------------------------------------------------------------

    function toDecimal(ratio) {
      let decimal = Number(ratio);
      let numbers;

      if (!decimal) {
        numbers = ratio.match(/^(\d+)\s*\/\s*(\d+)$/);
        decimal = numbers[1] / numbers[2];
      }

      return decimal;
    }

    function toDpi(resolution) {
      const value = parseFloat(resolution);
      const units = String(resolution).match(RE_RESOLUTION_UNIT)[1];

      switch (units) {
      case 'dpcm': return value / 2.54;
      case 'dppx': return value * 96;
      default    : return value;
      }
    }

    function toPx(length) {
      const value = parseFloat(length);
      const units = String(length).match(RE_LENGTH_UNIT)[1];

      switch (units) {
      case 'em' : return value * 16;
      case 'rem': return value * 16;
      case 'cm' : return value * 96 / 2.54;
      case 'mm' : return value * 96 / 2.54 / 10;
      case 'in' : return value * 96;
      case 'pt' : return value * 72;
      case 'pc' : return value * 72 / 12;
      default   : return value;
      }
    }


  /***/
  }),

  /***/ '../node_modules/dateformat/lib/dateformat.js':
  /* !****************************************************!*\
  !*** ../node_modules/dateformat/lib/dateformat.js ***!
  \****************************************************/
  /***/ (function(module, exports, __webpack_require__) {

    let __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 */

    (global => {
      const dateFormat = (() => {
        const token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|"[^"]*"|'[^']*'/g;
        const timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
        const timezoneClip = /[^-+\dA-Z]/g;

        // Regexes and supporting functions are cached through closure
        return function(date, mask, utc, gmt) {

          // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)
          if (arguments.length === 1 && kindOf(date) === 'string' && !/\d/.test(date)) {
            mask = date;
            date = undefined;
          }

          date = date || new Date;

          if(!(date instanceof Date)) {
            date = new Date(date);
          }

          if (isNaN(date)) {
            throw TypeError('Invalid date');
          }

          mask = String(dateFormat.masks[mask] || mask || dateFormat.masks['default']);

          // Allow setting the utc/gmt argument via the mask
          const maskSlice = mask.slice(0, 4);
          if (maskSlice === 'UTC:' || maskSlice === 'GMT:') {
            mask = mask.slice(4);
            utc = true;
            if (maskSlice === 'GMT:') {
              gmt = true;
            }
          }

          const _ = utc ? 'getUTC' : 'get';
          const d = date[`${_}Date`]();
          const D = date[`${_}Day`]();
          const m = date[`${_}Month`]();
          const y = date[`${_}FullYear`]();
          const H = date[`${_}Hours`]();
          const M = date[`${_}Minutes`]();
          const s = date[`${_}Seconds`]();
          const L = date[`${_}Milliseconds`]();
          const o = utc ? 0 : date.getTimezoneOffset();
          const W = getWeek(date);
          const N = getDayOfWeek(date);
          const flags = {
            d,
            dd:   pad(d),
            ddd:  dateFormat.i18n.dayNames[D],
            dddd: dateFormat.i18n.dayNames[D + 7],
            m:    m + 1,
            mm:   pad(m + 1),
            mmm:  dateFormat.i18n.monthNames[m],
            mmmm: dateFormat.i18n.monthNames[m + 12],
            yy:   String(y).slice(2),
            yyyy: y,
            h:    H % 12 || 12,
            hh:   pad(H % 12 || 12),
            H,
            HH:   pad(H),
            M,
            MM:   pad(M),
            s,
            ss:   pad(s),
            l:    pad(L, 3),
            L:    pad(Math.round(L / 10)),
            t:    H < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1],
            tt:   H < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3],
            T:    H < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5],
            TT:   H < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7],
            Z:    gmt ? 'GMT' : utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
            o:    (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
            S:    ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
            W,
            N
          };

          return mask.replace(token, match => {
            if (match in flags) {
              return flags[match];
            }
            return match.slice(1, match.length - 1);
          });
        };
      })();

      dateFormat.masks = {
        'default':               'ddd mmm dd yyyy HH:MM:ss',
        'shortDate':             'm/d/yy',
        'mediumDate':            'mmm d, yyyy',
        'longDate':              'mmmm d, yyyy',
        'fullDate':              'dddd, mmmm d, yyyy',
        'shortTime':             'h:MM TT',
        'mediumTime':            'h:MM:ss TT',
        'longTime':              'h:MM:ss TT Z',
        'isoDate':               'yyyy-mm-dd',
        'isoTime':               'HH:MM:ss',
        'isoDateTime':           'yyyy-mm-dd\'T\'HH:MM:sso',
        'isoUtcDateTime':        'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'',
        'expiresHeaderFormat':   'ddd, dd mmm yyyy HH:MM:ss Z'
      };

      // Internationalization strings
      dateFormat.i18n = {
        dayNames: [
          'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',
          'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
        ],
        monthNames: [
          'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',
          'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
        ],
        timeNames: [
          'a', 'p', 'am', 'pm', 'A', 'P', 'AM', 'PM'
        ]
      };

      function pad(val, len) {
        val = String(val);
        len = len || 2;
        while (val.length < len) {
          val = `0${val}`;
        }
        return val;
      }

      /**
   * Get the ISO 8601 week number
   * Based on comments from
   * http://techblog.procurios.nl/k/n618/news/view/33796/14863/Calculate-ISO-8601-week-and-year-in-javascript.html
   *
   * @param  {Object} `date`
   * @return {Number}
   */
      function getWeek(date) {
        // Remove time components of date
        const targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

        // Change date to Thursday same week
        targetThursday.setDate(targetThursday.getDate() - ((targetThursday.getDay() + 6) % 7) + 3);

        // Take January 4th as it is always in week 1 (see ISO 8601)
        const firstThursday = new Date(targetThursday.getFullYear(), 0, 4);

        // Change date to Thursday same week
        firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);

        // Check if daylight-saving-time-switch occurred and correct for it
        const ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
        targetThursday.setHours(targetThursday.getHours() - ds);

        // Number of weeks between target Thursday and first Thursday
        const weekDiff = (targetThursday - firstThursday) / (86400000 * 7);
        return 1 + Math.floor(weekDiff);
      }

      /**
   * Get ISO-8601 numeric representation of the day of the week
   * 1 (for Monday) through 7 (for Sunday)
   *
   * @param  {Object} `date`
   * @return {Number}
   */
      function getDayOfWeek(date) {
        let dow = date.getDay();
        if(dow === 0) {
          dow = 7;
        }
        return dow;
      }

      /**
   * kind-of shortcut
   * @param  {*} val
   * @return {String}
   */
      function kindOf(val) {
        if (val === null) {
          return 'null';
        }

        if (val === undefined) {
          return 'undefined';
        }

        if (typeof val !== 'object') {
          return typeof val;
        }

        if (Array.isArray(val)) {
          return 'array';
        }

        return {}.toString.call(val)
          .slice(8, -1).toLowerCase();
      }


      if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = ((() => {
          return dateFormat;
        })).call(exports, __webpack_require__, exports, module),
        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      } else {}
    })(this);


    /***/ }),

  /***/ '../node_modules/deepmerge/dist/cjs.js':
  /* !*********************************************!*\
  !*** ../node_modules/deepmerge/dist/cjs.js ***!
  \*********************************************/
  /***/ ((module) => {
    const isMergeableObject = function isMergeableObject(value) {
      return isNonNullObject(value)
          && !isSpecial(value);
    };

    function isNonNullObject(value) {
      return !!value && typeof value === 'object';
    }

    function isSpecial(value) {
      const stringValue = Object.prototype.toString.call(value);

      return stringValue === '[object RegExp]'
          || stringValue === '[object Date]'
          || isReactElement(value);
    }

    // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
    const canUseSymbol = typeof Symbol === 'function' && Symbol.for;
    const REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

    function isReactElement({$$typeof}) {
      return $$typeof === REACT_ELEMENT_TYPE;
    }

    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }

    function cloneUnlessOtherwiseSpecified(value, options) {
      return (options.clone !== false && options.isMergeableObject(value))
        ? deepmerge(emptyTarget(value), value, options)
        : value;
    }

    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(element => {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }

    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      const customMerge = options.customMerge(key);
      return typeof customMerge === 'function' ? customMerge : deepmerge;
    }

    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols
        ? Object.getOwnPropertySymbols(target).filter(symbol => {
          return target.propertyIsEnumerable(symbol);
        })
        : [];
    }

    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }

    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch(_) {
        return false;
      }
    }

    // Protects from prototype poisoning and unexpected merging up the prototype chain.
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
          && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
              && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.
    }

    function mergeObject(target, source, options) {
      const destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(key => {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(key => {
        if (propertyIsUnsafe(target, key)) {
          return;
        }

        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }

    function deepmerge(target, source, options = {}) {
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
      // implementations can use it. The caller may not replace it.
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

      const sourceIsArray = Array.isArray(source);
      const targetIsArray = Array.isArray(target);
      const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }

    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error('first argument should be an array');
      }

      return array.reduce((prev, next) => {
        return deepmerge(prev, next, options);
      }, {});
    };

    const deepmerge_1 = deepmerge;

    module.exports = deepmerge_1;


  /***/
  }),

  /***/ '../node_modules/get-value/index.js':
  /* !******************************************!*\
  !*** ../node_modules/get-value/index.js ***!
  \******************************************/
  /***/ ((module) => {

    /* !
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

    module.exports = (obj, prop, a, b, c) => {
      if (!isObject(obj) || !prop) {
        return obj;
      }

      prop = toString(prop);

      // allowing for multiple properties to be passed as
      // a string or array, but much faster (3-4x) than doing
      // `[].slice.call(arguments)`
      if (a) {
        prop += `.${toString(a)}`;
      }
      if (b) {
        prop += `.${toString(b)}`;
      }
      if (c) {
        prop += `.${toString(c)}`;
      }

      if (prop in obj) {
        return obj[prop];
      }

      const segs = prop.split('.');
      const len = segs.length;
      let i = -1;

      while (obj && (++i < len)) {
        let key = segs[i];
        while (key[key.length - 1] === '\\') {
          key = `${key.slice(0, -1)}.${segs[++i]}`;
        }
        obj = obj[key];
      }
      return obj;
    };

    function isObject(val) {
      return val !== null && (typeof val === 'object' || typeof val === 'function');
    }

    function toString(val) {
      if (!val) {
        return '';
      }
      if (Array.isArray(val)) {
        return val.join('.');
      }
      return val;
    }


    /***/ }),

  /***/ '../node_modules/has-value/index.js':
  /* !******************************************!*\
  !*** ../node_modules/has-value/index.js ***!
  \******************************************/
  /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
  /* !
   * has-value <https://github.com/jonschlinkert/has-value>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */


    const isObject = __webpack_require__(/* ! isobject */ '../node_modules/has-value/node_modules/isobject/index.js');
    const hasValues = __webpack_require__(/* ! has-values */ '../node_modules/has-values/index.js');
    const get = __webpack_require__(/* ! get-value */ '../node_modules/get-value/index.js');

    module.exports = (obj, prop, noZero) => {
      if (isObject(obj)) {
        return hasValues(get(obj, prop), noZero);
      }
      return hasValues(obj, prop);
    };


  /***/
  }),

  /***/ '../node_modules/has-value/node_modules/isobject/index.js':
  /* !****************************************************************!*\
  !*** ../node_modules/has-value/node_modules/isobject/index.js ***!
  \****************************************************************/
  /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
  /* !
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */


    const isArray = __webpack_require__(/* ! isarray */ '../node_modules/isarray/index.js');

    module.exports = function isObject(val) {
      return val != null && typeof val === 'object' && isArray(val) === false;
    };


  /***/
  }),

  /***/ '../node_modules/has-values/index.js':
  /* !*******************************************!*\
  !*** ../node_modules/has-values/index.js ***!
  \*******************************************/
  /***/ ((module) => {
  /* !
   * has-values <https://github.com/jonschlinkert/has-values>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */


    module.exports = function hasValue(o, noZero) {
      if (o === null || o === undefined) {
        return false;
      }

      if (typeof o === 'boolean') {
        return true;
      }

      if (typeof o === 'number') {
        if (o === 0 && noZero === true) {
          return false;
        }
        return true;
      }

      if (o.length !== undefined) {
        return o.length !== 0;
      }

      for (const key in o) {
        if (o.hasOwnProperty(key)) {
          return true;
        }
      }
      return false;
    };


  /***/
  }),

  /***/ '../node_modules/is-plain-object/index.js':
  /* !************************************************!*\
  !*** ../node_modules/is-plain-object/index.js ***!
  \************************************************/
  /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
  /* !
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */


    const isObject = __webpack_require__(/* ! isobject */ '../node_modules/isobject/index.js');

    function isObjectObject(o) {
      return isObject(o) === true
      && Object.prototype.toString.call(o) === '[object Object]';
    }

    module.exports = function isPlainObject(o) {
      let ctor;
      let prot;

      if (isObjectObject(o) === false) {
        return false;
      }

      // If has modified constructor
      ctor = o.constructor;
      if (typeof ctor !== 'function') {
        return false;
      }

      // If has modified prototype
      prot = ctor.prototype;
      if (isObjectObject(prot) === false) {
        return false;
      }

      // If constructor does not have an Object-specific method
      if (prot.hasOwnProperty('isPrototypeOf') === false) {
        return false;
      }

      // Most likely a plain Object
      return true;
    };


  /***/
  }),

  /***/ '../node_modules/isarray/index.js':
  /* !****************************************!*\
  !*** ../node_modules/isarray/index.js ***!
  \****************************************/
  /***/ ((module) => {

    const toString = {}.toString;

    module.exports = Array.isArray || (arr => {
      return toString.call(arr) == '[object Array]';
    });


    /***/ }),

  /***/ '../node_modules/isobject/index.js':
  /* !*****************************************!*\
  !*** ../node_modules/isobject/index.js ***!
  \*****************************************/
  /***/ ((module) => {
  /* !
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */


    module.exports = function isObject(val) {
      return val != null && typeof val === 'object' && Array.isArray(val) === false;
    };


  /***/
  }),

  /***/ '../node_modules/js-cookie/src/js.cookie.js':
  /* !**************************************************!*\
  !*** ../node_modules/js-cookie/src/js.cookie.js ***!
  \**************************************************/
  /***/ ((module, exports, __webpack_require__) => {
    let __WEBPACK_AMD_DEFINE_FACTORY__;
    let __WEBPACK_AMD_DEFINE_RESULT__;
    /* !
* JavaScript Cookie v2.2.1
* https://github.com/js-cookie/js-cookie
*
* Copyright 2006, 2015 Klaus Hartl & Fagner Brack
* Released under the MIT license
*/
    (factory => {
      let registeredInModuleLoader;
      if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
        __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
          (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
          __WEBPACK_AMD_DEFINE_FACTORY__),
        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        registeredInModuleLoader = true;
      }
      if (true) {
        module.exports = factory();
        registeredInModuleLoader = true;
      }
      if (!registeredInModuleLoader) {
        const OldCookies = window.Cookies;
        const api = window.Cookies = factory();
        api.noConflict = () => {
          window.Cookies = OldCookies;
          return api;
        };
      }
    })(() => {
      function extend(...args) {
        let i = 0;
        const result = {};
        for (; i < args.length; i++) {
          const attributes = args[ i ];
          for (const key in attributes) {
            result[key] = attributes[key];
          }
        }
        return result;
      }

      function decode(s) {
        return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
      }

      function init(converter) {
        function api() {}

        function set(key, value, attributes) {
          if (typeof document === 'undefined') {
            return;
          }

          attributes = extend({
            path: '/'
          }, api.defaults, attributes);

          if (typeof attributes.expires === 'number') {
            attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
          }

          // We're using "expires" because "max-age" is not supported by IE
          attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

          try {
            const result = JSON.stringify(value);
            if (/^[\{\[]/.test(result)) {
              value = result;
            }
          } catch (e) {}

          value = converter.write ?
            converter.write(value, key) :
            encodeURIComponent(String(value))
              .replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

          key = encodeURIComponent(String(key))
            .replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
            .replace(/[\(\)]/g, escape);

          let stringifiedAttributes = '';
          for (const attributeName in attributes) {
            if (!attributes[attributeName]) {
              continue;
            }
            stringifiedAttributes += `; ${attributeName}`;
            if (attributes[attributeName] === true) {
              continue;
            }

            // Considers RFC 6265 section 5.2:
            // ...
            // 3.  If the remaining unparsed-attributes contains a %x3B (";")
            //     character:
            // Consume the characters of the unparsed-attributes up to,
            // not including, the first %x3B (";") character.
            // ...
            stringifiedAttributes += `=${attributes[attributeName].split(';')[0]}`;
          }

          return document.cookie = `${key}=${value}${stringifiedAttributes}`;
        }

        function get(key, json) {
          if (typeof document === 'undefined') {
            return;
          }

          const jar = {};
          // To prevent the for loop in the first place assign an empty array
          // in case there are no cookies at all.
          const cookies = document.cookie ? document.cookie.split('; ') : [];
          let i = 0;

          for (; i < cookies.length; i++) {
            const parts = cookies[i].split('=');
            let cookie = parts.slice(1).join('=');

            if (!json && cookie.charAt(0) === '"') {
              cookie = cookie.slice(1, -1);
            }

            try {
              const name = decode(parts[0]);
              cookie = (converter.read || converter)(cookie, name) ||
                          decode(cookie);

              if (json) {
                try {
                  cookie = JSON.parse(cookie);
                } catch (e) {}
              }

              jar[name] = cookie;

              if (key === name) {
                break;
              }
            } catch (e) {}
          }

          return key ? jar[key] : jar;
        }

        api.set = set;
        api.get = key => {
          return get(key, false /* read as raw */);
        };
        api.getJSON = key => {
          return get(key, true /* read as json */);
        };
        api.remove = (key, attributes) => {
          set(key, '', extend(attributes, {
            expires: -1
          }));
        };

        api.defaults = {};

        api.withConverter = init;

        return api;
      }

      return init(() => {});
    });


  /***/
  }),

  /***/ '../node_modules/omit-deep/index.js':
  /* !******************************************!*\
  !*** ../node_modules/omit-deep/index.js ***!
  \******************************************/
  /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    const isObject = __webpack_require__(/* ! is-plain-object */ '../node_modules/is-plain-object/index.js');
    const unset = __webpack_require__(/* ! unset-value */ '../node_modules/unset-value/index.js');

    module.exports = function omitDeep(value, keys) {
      if (typeof value === 'undefined') {
        return {};
      }

      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          value[i] = omitDeep(value[i], keys);
        }
        return value;
      }

      if (!isObject(value)) {
        return value;
      }

      if (typeof keys === 'string') {
        keys = [keys];
      }

      if (!Array.isArray(keys)) {
        return value;
      }

      for (let j = 0; j < keys.length; j++) {
        unset(value, keys[j]);
      }

      for (const key in value) {
        if (value.hasOwnProperty(key)) {
          value[key] = omitDeep(value[key], keys);
        }
      }

      return value;
    };


  /***/
  }),

  /***/ '../node_modules/simplejsonconf/dist/main.js':
  /* !***************************************************!*\
  !*** ../node_modules/simplejsonconf/dist/main.js ***!
  \***************************************************/
  /***/ ((module) => {

    !((n, t) => {
      true ? module.exports = t() : 0;
    })(
      window,
      () => {
        return (n => {
          const t = {};function r(e) {
            if(t[e]) {
              return t[e].exports;
            }const o = t[e] = {i:e, l:!1, exports:{}};return n[e].call(o.exports, o, o.exports, r), o.l = !0, o.exports;
          }return r.m = n, r.c = t, r.d = (n, t, e) => {
            r.o(n, t) || Object.defineProperty(n, t, {enumerable:!0, get:e});
          }, r.r = n => {
            'undefined' !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, {value:'Module'}), Object.defineProperty(n, '__esModule', {value:!0});
          }, r.t = (n, t) => {
            if(1 & t && (n = r(n)), 8 & t) {
              return n;
            }if(4 & t && 'object' === typeof n && n && n.__esModule) {
              return n;
            }const e = Object.create(null);if(r.r(e), Object.defineProperty(e, 'default', {enumerable:!0, value:n}), 2 & t && 'string' !== typeof n) {
              for(const o in n) {
                r.d(e, o, (t => {
                  return n[t];
                }).bind(null, o));
              }
            }return e;
          }, r.n = n => {
            const t = n && n.__esModule ? () => {
              return n.default;
            } : () => {
              return n;
            };return r.d(t, 'a', t), t;
          }, r.o = (n, t) => {
            return Object.prototype.hasOwnProperty.call(n, t);
          }, r.p = '', r(r.s = 3);
        })(
          [(n, t) => {
            function r(n) {
              return (r = 'function' === typeof Symbol && 'symbol' === typeof Symbol.iterator ? n => {
                return typeof n;
              } : n => {
                return n && 'function' === typeof Symbol && n.constructor === Symbol && n !== Symbol.prototype ? 'symbol' : typeof n;
              })(n);
            }function e(t) {
              return 'function' === typeof Symbol && 'symbol' === r(Symbol.iterator) ? n.exports = e = n => {
                return r(n);
              } : n.exports = e = n => {
                return n && 'function' === typeof Symbol && n.constructor === Symbol && n !== Symbol.prototype ? 'symbol' : r(n);
              }, e(t);
            }n.exports = e;
          }, (n, t, r) => {
            const e = r(5);
            const o = r(6);
            const u = r(7);
            n.exports = (n, t) => {
              return e(n) || o(n, t) || u();
            };
          }, (n, t) => {
            n.exports = (n, t, r) => {
              return t in n ? Object.defineProperty(n, t, {value:r, enumerable:!0, configurable:!0, writable:!0}) : n[t] = r, n;
            };
          }, (n, t, r) => {
            n.exports = r(4);
          }, (n, t, r) => {
            r.r(t);
            const e = r(1);
            const o = r.n(e);
            const u = r(2);
            const i = r.n(u);
            const f = r(0);
            const c = r.n(f);
            const a = n => {
              return void 0 === n ? n : JSON.parse(JSON.stringify(n));
            };
            const l = n => {
              return n.split(/\./g);
            };
            const s = n => {
              return void 0 === n || null === n;
            };
            const p = n => {
              return!!n && 'object' === c()(n) && !Array.isArray(n);
            };
            const y = function n(t, r) {
              if(p(t) && p(r)) {
                for(const e in r) {
                  p(r[e]) ? (t[e] && c()(t[e]) === c()(r[e]) || Object.assign(t, i()({}, e, {})), n(t[e], r[e])) : Object.assign(t, i()({}, e, r[e]));
                }return t;
              }return r;
            };
            const b = (n, t, r) => {
              if(s(t)) {
                return n;
              }let e;try{
                e = l(t).reduce((n, t) => {
                  return n[t];
                }, Object.assign({},n));
              }catch(n) {}return void 0 === e ? r : e;
            };
            const d = (n, t, r) => {
              const e = l(t), o = e.length;if(r) {
                for(let u = n, i = 0;i < o;i++) {
                  const f = e[i];void 0 === u[f] && (u[f] = {}), u = u[f];
                }
              }const c = 1 === o ? e[0] : e.pop();return[1 === o ? n : b(n, e.join('.')), c];
            };
            t.default = n => {
              let t;
              const r = n => {
                return t = a(n);
              };
              return r(n), {get(n, r) {
                return a(b(t, n, r));
              }, set(n, r) {
                const e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};return a(((n, t, r, {parse, merge}) => {
                  if(!1 !== parse) {
                    try{
                      r = void 0 === r ? r : JSON.parse(r);
                    }catch(n) {}
                  }if(s(t)) {
                    const u = !1 !== merge ? y(n, r) : r;return Object.assign(n, u);
                  }
                  const i = d(n, t, !0);
                  const f = o()(i, 2);
                  const c = f[0];
                  const a = f[1];
                  s(c[a]) && (c[a] = {});const l = !1 !== merge ? y(c[a], r) : r;return c[a] = l, l;
                })(t, n, r, e));
              }, push(n, r) {
                return a(
                  ((n, t, r) => {
                    const e = b(n, t);if(!Array.isArray(e)) {
                      throw new Error('The key \''.concat(t, '\' is not an array'));
                    }return e.push(r), e;
                  })(t, n, r)
                );
              }, remove(n) {
                return a(((n, t) => {
                  const r = d(n, t);
                  const e = o()(r, 2);
                  const u = e[0];
                  const i = e[1];
                  return void 0 !== u[i] && (u instanceof Array ? u.splice(u.indexOf(u[i]), 1) : delete u[i]), u;
                })(t, n));
              }, reset(t) {
                return a(r(t || n));
              }, toString() {
                return JSON.stringify(t);
              }};
            };
          }, (n, t) => {
            n.exports = n => {
              if(Array.isArray(n)) {
                return n;
              }
            };
          }, (n, t) => {
            n.exports = (n, t) => {
              const r = [];
              let e = !0;
              let o = !1;
              let u = void 0;
              try{
                for(var i, f = n[Symbol.iterator]();!(e = (i = f.next()).done) && (r.push(i.value), !t || r.length !== t);e = !0) {}
              }catch(n) {
                o = !0, u = n;
              }finally{
                try{
                  e || null == f.return || f.return();
                }finally{
                  if(o) {
                    throw u;
                  }
                }
              }return r;
            };
          }, (n, t) => {
            n.exports = () => {
              throw new TypeError('Invalid attempt to destructure non-iterable instance');
            };
          }]
        );
      }
    );


    /***/ }),

  /***/ '../node_modules/unset-value/index.js':
  /* !********************************************!*\
  !*** ../node_modules/unset-value/index.js ***!
  \********************************************/
  /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
  /* !
   * unset-value <https://github.com/jonschlinkert/unset-value>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */


    const isObject = __webpack_require__(/* ! isobject */ '../node_modules/isobject/index.js');
    const has = __webpack_require__(/* ! has-value */ '../node_modules/has-value/index.js');

    module.exports = function unset(obj, prop) {
      if (!isObject(obj)) {
        throw new TypeError('expected an object.');
      }
      if (obj.hasOwnProperty(prop)) {
        delete obj[prop];
        return true;
      }

      if (has(obj, prop)) {
        const segs = prop.split('.');
        let last = segs.pop();
        while (segs.length && segs[segs.length - 1].slice(-1) === '\\') {
          last = `${segs.pop().slice(0, -1)}.${last}`;
        }
        while (segs.length) {
          obj = obj[prop = segs.shift()];
        }
        return (delete obj[last]);
      }
      return true;
    };


  /***/
  }),

  /***/ '../osjs-client/node_modules/hyperapp/src/index.js':
  /* !*********************************************************!*\
  !*** ../osjs-client/node_modules/hyperapp/src/index.js ***!
  \*********************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
      /* harmony export */   'app': () => (/* binding */ app),
      /* harmony export */   'h': () => (/* binding */ h)
      /* harmony export */});
    function h(name, attributes) {
      const rest = [];
      const children = [];
      let length = arguments.length;

      while (length-- > 2) {
        rest.push(arguments[length]);
      }

      while (rest.length) {
        const node = rest.pop();
        if (node && node.pop) {
          for (length = node.length; length--;) {
            rest.push(node[length]);
          }
        } else if (node != null && node !== true && node !== false) {
          children.push(node);
        }
      }

      return typeof name === 'function'
        ? name(attributes || {}, children)
        : {
          nodeName: name,
          attributes: attributes || {},
          children,
          key: attributes && attributes.key
        };
    }

    function app(state, actions, view, container) {
      const map = [].map;
      let rootElement = (container && container.children[0]) || null;
      let oldNode = rootElement && recycleElement(rootElement);
      const lifecycle = [];
      let skipRender;
      let isRecycling = true;
      let globalState = clone(state);
      const wiredActions = wireStateToActions([], globalState, clone(actions));

      scheduleRender();

      return wiredActions;

      function recycleElement({nodeName, childNodes}) {
        return {
          nodeName: nodeName.toLowerCase(),
          attributes: {},
          children: map.call(childNodes, element => {
            return element.nodeType === 3 // Node.TEXT_NODE
              ? element.nodeValue
              : recycleElement(element);
          })
        };
      }

      function resolveNode(node) {
        return typeof node === 'function'
          ? resolveNode(node(globalState, wiredActions))
          : node != null
            ? node
            : '';
      }

      function render() {
        skipRender = !skipRender;

        const node = resolveNode(view);

        if (container && !skipRender) {
          rootElement = patch(container, rootElement, oldNode, (oldNode = node));
        }

        isRecycling = false;

        while (lifecycle.length) {
          lifecycle.pop()();
        }
      }

      function scheduleRender() {
        if (!skipRender) {
          skipRender = true;
          setTimeout(render);
        }
      }

      function clone(target, source) {
        const out = {};

        for (var i in target) {
          out[i] = target[i];
        }
        for (var i in source) {
          out[i] = source[i];
        }

        return out;
      }

      function setPartialState(path, value, source) {
        const target = {};
        if (path.length) {
          target[path[0]] =
          path.length > 1
            ? setPartialState(path.slice(1), value, source[path[0]])
            : value;
          return clone(source, target);
        }
        return value;
      }

      function getPartialState(path, source) {
        let i = 0;
        while (i < path.length) {
          source = source[path[i++]];
        }
        return source;
      }

      function wireStateToActions(path, state, actions) {
        for (const key in actions) {
          typeof actions[key] === 'function' ? ((key, action) => {
            actions[key] = data => {
              let result = action(data);

              if (typeof result === 'function') {
                result = result(getPartialState(path, globalState), actions);
              }

              if (
                result &&
                  result !== (state = getPartialState(path, globalState)) &&
                  !result.then // !isPromise
              ) {
                scheduleRender(
                  (globalState = setPartialState(
                    path,
                    clone(state, result),
                    globalState
                  ))
                );
              }

              return result;
            };
          })(key, actions[key]) : wireStateToActions(
            path.concat(key),
            (state[key] = clone(state[key])),
            (actions[key] = clone(actions[key]))
          );
        }

        return actions;
      }

      function getKey(node) {
        return node ? node.key : null;
      }

      function eventListener(event) {
        return event.currentTarget.events[event.type](event);
      }

      function updateAttribute(element, name, value, oldValue, isSvg) {
        if (name === 'key') {
        } else if (name === 'style') {
          if (typeof value === 'string') {
            element.style.cssText = value;
          } else {
            if (typeof oldValue === 'string') {
              oldValue = element.style.cssText = '';
            }
            for (const i in clone(oldValue, value)) {
              const style = value == null || value[i] == null ? '' : value[i];
              if (i[0] === '-') {
                element.style.setProperty(i, style);
              } else {
                element.style[i] = style;
              }
            }
          }
        } else {
          if (name[0] === 'o' && name[1] === 'n') {
            name = name.slice(2);

            if (element.events) {
              if (!oldValue) {
                oldValue = element.events[name];
              }
            } else {
              element.events = {};
            }

            element.events[name] = value;

            if (value) {
              if (!oldValue) {
                element.addEventListener(name, eventListener);
              }
            } else {
              element.removeEventListener(name, eventListener);
            }
          } else if (
            name in element &&
          name !== 'list' &&
          name !== 'type' &&
          name !== 'draggable' &&
          name !== 'spellcheck' &&
          name !== 'translate' &&
          !isSvg
          ) {
            element[name] = value == null ? '' : value;
          } else if (value != null && value !== false) {
            element.setAttribute(name, value);
          }

          if (value == null || value === false) {
            element.removeAttribute(name);
          }
        }
      }

      function createElement(node, isSvg) {
        const element =
        typeof node === 'string' || typeof node === 'number'
          ? document.createTextNode(node)
          : (isSvg = isSvg || node.nodeName === 'svg')
            ? document.createElementNS(
              'http://www.w3.org/2000/svg',
              node.nodeName
            )
            : document.createElement(node.nodeName);

        const attributes = node.attributes;
        if (attributes) {
          if (attributes.oncreate) {
            lifecycle.push(() => {
              attributes.oncreate(element);
            });
          }

          for (let i = 0; i < node.children.length; i++) {
            element.appendChild(
              createElement(
                (node.children[i] = resolveNode(node.children[i])),
                isSvg
              )
            );
          }

          for (const name in attributes) {
            updateAttribute(element, name, attributes[name], null, isSvg);
          }
        }

        return element;
      }

      function updateElement(element, oldAttributes, attributes, isSvg) {
        for (const name in clone(oldAttributes, attributes)) {
          if (
            attributes[name] !==
          (name === 'value' || name === 'checked'
            ? element[name]
            : oldAttributes[name])
          ) {
            updateAttribute(
              element,
              name,
              attributes[name],
              oldAttributes[name],
              isSvg
            );
          }
        }

        const cb = isRecycling ? attributes.oncreate : attributes.onupdate;
        if (cb) {
          lifecycle.push(() => {
            cb(element, oldAttributes);
          });
        }
      }

      function removeChildren(element, node) {
        const attributes = node.attributes;
        if (attributes) {
          for (let i = 0; i < node.children.length; i++) {
            removeChildren(element.childNodes[i], node.children[i]);
          }

          if (attributes.ondestroy) {
            attributes.ondestroy(element);
          }
        }
        return element;
      }

      function removeElement(parent, element, node) {
        function done() {
          parent.removeChild(removeChildren(element, node));
        }

        const cb = node.attributes && node.attributes.onremove;
        if (cb) {
          cb(element, done);
        } else {
          done();
        }
      }

      function patch(parent, element, oldNode, node, isSvg) {
        if (node === oldNode) {
        } else if (oldNode == null || oldNode.nodeName !== node.nodeName) {
          const newElement = createElement(node, isSvg);
          parent.insertBefore(newElement, element);

          if (oldNode != null) {
            removeElement(parent, element, oldNode);
          }

          element = newElement;
        } else if (oldNode.nodeName == null) {
          element.nodeValue = node;
        } else {
          updateElement(
            element,
            oldNode.attributes,
            node.attributes,
            (isSvg = isSvg || node.nodeName === 'svg')
          );

          const oldKeyed = {};
          const newKeyed = {};
          const oldElements = [];
          const oldChildren = oldNode.children;
          const children = node.children;

          for (var i = 0; i < oldChildren.length; i++) {
            oldElements[i] = element.childNodes[i];

            var oldKey = getKey(oldChildren[i]);
            if (oldKey != null) {
              oldKeyed[oldKey] = [oldElements[i], oldChildren[i]];
            }
          }

          var i = 0;
          let k = 0;

          while (k < children.length) {
            var oldKey = getKey(oldChildren[i]);
            const newKey = getKey((children[k] = resolveNode(children[k])));

            if (newKeyed[oldKey]) {
              i++;
              continue;
            }

            if (newKey != null && newKey === getKey(oldChildren[i + 1])) {
              if (oldKey == null) {
                removeElement(element, oldElements[i], oldChildren[i]);
              }
              i++;
              continue;
            }

            if (newKey == null || isRecycling) {
              if (oldKey == null) {
                patch(element, oldElements[i], oldChildren[i], children[k], isSvg);
                k++;
              }
              i++;
            } else {
              const keyedNode = oldKeyed[newKey] || [];

              if (oldKey === newKey) {
                patch(element, keyedNode[0], keyedNode[1], children[k], isSvg);
                i++;
              } else if (keyedNode[0]) {
                patch(
                  element,
                  element.insertBefore(keyedNode[0], oldElements[i]),
                  keyedNode[1],
                  children[k],
                  isSvg
                );
              } else {
                patch(element, oldElements[i], null, children[k], isSvg);
              }

              newKeyed[newKey] = children[k];
              k++;
            }
          }

          while (i < oldChildren.length) {
            if (getKey(oldChildren[i]) == null) {
              removeElement(element, oldElements[i], oldChildren[i]);
            }
            i++;
          }

          for (var i in oldKeyed) {
            if (!newKeyed[i]) {
              removeElement(element, oldKeyed[i][0], oldKeyed[i][1]);
            }
          }
        }
        return element;
      }
    }


  /***/
  }),

  /***/ '../osjs-dialogs/node_modules/deepmerge/dist/es.js':
  /* !*********************************************************!*\
  !*** ../osjs-dialogs/node_modules/deepmerge/dist/es.js ***!
  \*********************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
      /* harmony export */   'default': () => (__WEBPACK_DEFAULT_EXPORT__)
      /* harmony export */});
    const isMergeableObject = function isMergeableObject(value) {
      return isNonNullObject(value)
          && !isSpecial(value);
    };

    function isNonNullObject(value) {
      return !!value && typeof value === 'object';
    }

    function isSpecial(value) {
      const stringValue = Object.prototype.toString.call(value);

      return stringValue === '[object RegExp]'
          || stringValue === '[object Date]'
          || isReactElement(value);
    }

    // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
    const canUseSymbol = typeof Symbol === 'function' && Symbol.for;
    const REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

    function isReactElement({$$typeof}) {
      return $$typeof === REACT_ELEMENT_TYPE;
    }

    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }

    function cloneUnlessOtherwiseSpecified(value, options) {
      return (options.clone !== false && options.isMergeableObject(value))
        ? deepmerge(emptyTarget(value), value, options)
        : value;
    }

    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(element => {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }

    function mergeObject(target, source, options) {
      const destination = {};
      if (options.isMergeableObject(target)) {
        Object.keys(target).forEach(key => {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      Object.keys(source).forEach(key => {
        if (!options.isMergeableObject(source[key]) || !target[key]) {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        } else {
          destination[key] = deepmerge(target[key], source[key], options);
        }
      });
      return destination;
    }

    class deepmerge {
      constructor(target, source, options = {}) {
        options.arrayMerge = options.arrayMerge || defaultArrayMerge;
        options.isMergeableObject = options.isMergeableObject || isMergeableObject;

        const sourceIsArray = Array.isArray(source);
        const targetIsArray = Array.isArray(target);
        const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

        if (!sourceAndTargetTypesMatch) {
          return cloneUnlessOtherwiseSpecified(source, options);
        } else if (sourceIsArray) {
          return options.arrayMerge(target, source, options);
        } else {
          return mergeObject(target, source, options);
        }
      }

      static all(array, options) {
        if (!Array.isArray(array)) {
          throw new Error('first argument should be an array');
        }

        return array.reduce((prev, next) => {
          return deepmerge(prev, next, options);
        }, {});
      }
    }

    const deepmerge_1 = deepmerge;

    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (deepmerge_1);


  /***/
  }),

  /***/ '../osjs-dialogs/node_modules/hyperapp/src/index.js':
  /* !**********************************************************!*\
  !*** ../osjs-dialogs/node_modules/hyperapp/src/index.js ***!
  \**********************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
      /* harmony export */   'app': () => (/* binding */ app),
      /* harmony export */   'h': () => (/* binding */ h)
      /* harmony export */});
    function h(name, attributes) {
      const rest = [];
      const children = [];
      let length = arguments.length;

      while (length-- > 2) {
        rest.push(arguments[length]);
      }

      while (rest.length) {
        const node = rest.pop();
        if (node && node.pop) {
          for (length = node.length; length--;) {
            rest.push(node[length]);
          }
        } else if (node != null && node !== true && node !== false) {
          children.push(node);
        }
      }

      return typeof name === 'function'
        ? name(attributes || {}, children)
        : {
          nodeName: name,
          attributes: attributes || {},
          children,
          key: attributes && attributes.key
        };
    }

    function app(state, actions, view, container) {
      const map = [].map;
      let rootElement = (container && container.children[0]) || null;
      let oldNode = rootElement && recycleElement(rootElement);
      const lifecycle = [];
      let skipRender;
      let isRecycling = true;
      let globalState = clone(state);
      const wiredActions = wireStateToActions([], globalState, clone(actions));

      scheduleRender();

      return wiredActions;

      function recycleElement({nodeName, childNodes}) {
        return {
          nodeName: nodeName.toLowerCase(),
          attributes: {},
          children: map.call(childNodes, element => {
            return element.nodeType === 3 // Node.TEXT_NODE
              ? element.nodeValue
              : recycleElement(element);
          })
        };
      }

      function resolveNode(node) {
        return typeof node === 'function'
          ? resolveNode(node(globalState, wiredActions))
          : node != null
            ? node
            : '';
      }

      function render() {
        skipRender = !skipRender;

        const node = resolveNode(view);

        if (container && !skipRender) {
          rootElement = patch(container, rootElement, oldNode, (oldNode = node));
        }

        isRecycling = false;

        while (lifecycle.length) {
          lifecycle.pop()();
        }
      }

      function scheduleRender() {
        if (!skipRender) {
          skipRender = true;
          setTimeout(render);
        }
      }

      function clone(target, source) {
        const out = {};

        for (var i in target) {
          out[i] = target[i];
        }
        for (var i in source) {
          out[i] = source[i];
        }

        return out;
      }

      function setPartialState(path, value, source) {
        const target = {};
        if (path.length) {
          target[path[0]] =
          path.length > 1
            ? setPartialState(path.slice(1), value, source[path[0]])
            : value;
          return clone(source, target);
        }
        return value;
      }

      function getPartialState(path, source) {
        let i = 0;
        while (i < path.length) {
          source = source[path[i++]];
        }
        return source;
      }

      function wireStateToActions(path, state, actions) {
        for (const key in actions) {
          typeof actions[key] === 'function' ? ((key, action) => {
            actions[key] = data => {
              let result = action(data);

              if (typeof result === 'function') {
                result = result(getPartialState(path, globalState), actions);
              }

              if (
                result &&
                  result !== (state = getPartialState(path, globalState)) &&
                  !result.then // !isPromise
              ) {
                scheduleRender(
                  (globalState = setPartialState(
                    path,
                    clone(state, result),
                    globalState
                  ))
                );
              }

              return result;
            };
          })(key, actions[key]) : wireStateToActions(
            path.concat(key),
            (state[key] = clone(state[key])),
            (actions[key] = clone(actions[key]))
          );
        }

        return actions;
      }

      function getKey(node) {
        return node ? node.key : null;
      }

      function eventListener(event) {
        return event.currentTarget.events[event.type](event);
      }

      function updateAttribute(element, name, value, oldValue, isSvg) {
        if (name === 'key') {
        } else if (name === 'style') {
          if (typeof value === 'string') {
            element.style.cssText = value;
          } else {
            if (typeof oldValue === 'string') {
              oldValue = element.style.cssText = '';
            }
            for (const i in clone(oldValue, value)) {
              const style = value == null || value[i] == null ? '' : value[i];
              if (i[0] === '-') {
                element.style.setProperty(i, style);
              } else {
                element.style[i] = style;
              }
            }
          }
        } else {
          if (name[0] === 'o' && name[1] === 'n') {
            name = name.slice(2);

            if (element.events) {
              if (!oldValue) {
                oldValue = element.events[name];
              }
            } else {
              element.events = {};
            }

            element.events[name] = value;

            if (value) {
              if (!oldValue) {
                element.addEventListener(name, eventListener);
              }
            } else {
              element.removeEventListener(name, eventListener);
            }
          } else if (
            name in element &&
          name !== 'list' &&
          name !== 'type' &&
          name !== 'draggable' &&
          name !== 'spellcheck' &&
          name !== 'translate' &&
          !isSvg
          ) {
            element[name] = value == null ? '' : value;
          } else if (value != null && value !== false) {
            element.setAttribute(name, value);
          }

          if (value == null || value === false) {
            element.removeAttribute(name);
          }
        }
      }

      function createElement(node, isSvg) {
        const element =
        typeof node === 'string' || typeof node === 'number'
          ? document.createTextNode(node)
          : (isSvg = isSvg || node.nodeName === 'svg')
            ? document.createElementNS(
              'http://www.w3.org/2000/svg',
              node.nodeName
            )
            : document.createElement(node.nodeName);

        const attributes = node.attributes;
        if (attributes) {
          if (attributes.oncreate) {
            lifecycle.push(() => {
              attributes.oncreate(element);
            });
          }

          for (let i = 0; i < node.children.length; i++) {
            element.appendChild(
              createElement(
                (node.children[i] = resolveNode(node.children[i])),
                isSvg
              )
            );
          }

          for (const name in attributes) {
            updateAttribute(element, name, attributes[name], null, isSvg);
          }
        }

        return element;
      }

      function updateElement(element, oldAttributes, attributes, isSvg) {
        for (const name in clone(oldAttributes, attributes)) {
          if (
            attributes[name] !==
          (name === 'value' || name === 'checked'
            ? element[name]
            : oldAttributes[name])
          ) {
            updateAttribute(
              element,
              name,
              attributes[name],
              oldAttributes[name],
              isSvg
            );
          }
        }

        const cb = isRecycling ? attributes.oncreate : attributes.onupdate;
        if (cb) {
          lifecycle.push(() => {
            cb(element, oldAttributes);
          });
        }
      }

      function removeChildren(element, node) {
        const attributes = node.attributes;
        if (attributes) {
          for (let i = 0; i < node.children.length; i++) {
            removeChildren(element.childNodes[i], node.children[i]);
          }

          if (attributes.ondestroy) {
            attributes.ondestroy(element);
          }
        }
        return element;
      }

      function removeElement(parent, element, node) {
        function done() {
          parent.removeChild(removeChildren(element, node));
        }

        const cb = node.attributes && node.attributes.onremove;
        if (cb) {
          cb(element, done);
        } else {
          done();
        }
      }

      function patch(parent, element, oldNode, node, isSvg) {
        if (node === oldNode) {
        } else if (oldNode == null || oldNode.nodeName !== node.nodeName) {
          const newElement = createElement(node, isSvg);
          parent.insertBefore(newElement, element);

          if (oldNode != null) {
            removeElement(parent, element, oldNode);
          }

          element = newElement;
        } else if (oldNode.nodeName == null) {
          element.nodeValue = node;
        } else {
          updateElement(
            element,
            oldNode.attributes,
            node.attributes,
            (isSvg = isSvg || node.nodeName === 'svg')
          );

          const oldKeyed = {};
          const newKeyed = {};
          const oldElements = [];
          const oldChildren = oldNode.children;
          const children = node.children;

          for (var i = 0; i < oldChildren.length; i++) {
            oldElements[i] = element.childNodes[i];

            var oldKey = getKey(oldChildren[i]);
            if (oldKey != null) {
              oldKeyed[oldKey] = [oldElements[i], oldChildren[i]];
            }
          }

          var i = 0;
          let k = 0;

          while (k < children.length) {
            var oldKey = getKey(oldChildren[i]);
            const newKey = getKey((children[k] = resolveNode(children[k])));

            if (newKeyed[oldKey]) {
              i++;
              continue;
            }

            if (newKey != null && newKey === getKey(oldChildren[i + 1])) {
              if (oldKey == null) {
                removeElement(element, oldElements[i], oldChildren[i]);
              }
              i++;
              continue;
            }

            if (newKey == null || isRecycling) {
              if (oldKey == null) {
                patch(element, oldElements[i], oldChildren[i], children[k], isSvg);
                k++;
              }
              i++;
            } else {
              const keyedNode = oldKeyed[newKey] || [];

              if (oldKey === newKey) {
                patch(element, keyedNode[0], keyedNode[1], children[k], isSvg);
                i++;
              } else if (keyedNode[0]) {
                patch(
                  element,
                  element.insertBefore(keyedNode[0], oldElements[i]),
                  keyedNode[1],
                  children[k],
                  isSvg
                );
              } else {
                patch(element, oldElements[i], null, children[k], isSvg);
              }

              newKeyed[newKey] = children[k];
              k++;
            }
          }

          while (i < oldChildren.length) {
            if (getKey(oldChildren[i]) == null) {
              removeElement(element, oldElements[i], oldChildren[i]);
            }
            i++;
          }

          for (var i in oldKeyed) {
            if (!newKeyed[i]) {
              removeElement(element, oldKeyed[i][0], oldKeyed[i][1]);
            }
          }
        }
        return element;
      }
    }


  /***/
  }),

  /***/ '../osjs-panels/node_modules/hyperapp/src/index.js':
  /* !*********************************************************!*\
  !*** ../osjs-panels/node_modules/hyperapp/src/index.js ***!
  \*********************************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
      /* harmony export */   'app': () => (/* binding */ app),
      /* harmony export */   'h': () => (/* binding */ h)
      /* harmony export */});
    function h(name, attributes) {
      const rest = [];
      const children = [];
      let length = arguments.length;

      while (length-- > 2) {
        rest.push(arguments[length]);
      }

      while (rest.length) {
        const node = rest.pop();
        if (node && node.pop) {
          for (length = node.length; length--;) {
            rest.push(node[length]);
          }
        } else if (node != null && node !== true && node !== false) {
          children.push(node);
        }
      }

      return typeof name === 'function'
        ? name(attributes || {}, children)
        : {
          nodeName: name,
          attributes: attributes || {},
          children,
          key: attributes && attributes.key
        };
    }

    function app(state, actions, view, container) {
      const map = [].map;
      let rootElement = (container && container.children[0]) || null;
      let oldNode = rootElement && recycleElement(rootElement);
      const lifecycle = [];
      let skipRender;
      let isRecycling = true;
      let globalState = clone(state);
      const wiredActions = wireStateToActions([], globalState, clone(actions));

      scheduleRender();

      return wiredActions;

      function recycleElement({nodeName, childNodes}) {
        return {
          nodeName: nodeName.toLowerCase(),
          attributes: {},
          children: map.call(childNodes, element => {
            return element.nodeType === 3 // Node.TEXT_NODE
              ? element.nodeValue
              : recycleElement(element);
          })
        };
      }

      function resolveNode(node) {
        return typeof node === 'function'
          ? resolveNode(node(globalState, wiredActions))
          : node != null
            ? node
            : '';
      }

      function render() {
        skipRender = !skipRender;

        const node = resolveNode(view);

        if (container && !skipRender) {
          rootElement = patch(container, rootElement, oldNode, (oldNode = node));
        }

        isRecycling = false;

        while (lifecycle.length) {
          lifecycle.pop()();
        }
      }

      function scheduleRender() {
        if (!skipRender) {
          skipRender = true;
          setTimeout(render);
        }
      }

      function clone(target, source) {
        const out = {};

        for (var i in target) {
          out[i] = target[i];
        }
        for (var i in source) {
          out[i] = source[i];
        }

        return out;
      }

      function setPartialState(path, value, source) {
        const target = {};
        if (path.length) {
          target[path[0]] =
          path.length > 1
            ? setPartialState(path.slice(1), value, source[path[0]])
            : value;
          return clone(source, target);
        }
        return value;
      }

      function getPartialState(path, source) {
        let i = 0;
        while (i < path.length) {
          source = source[path[i++]];
        }
        return source;
      }

      function wireStateToActions(path, state, actions) {
        for (const key in actions) {
          typeof actions[key] === 'function' ? ((key, action) => {
            actions[key] = data => {
              let result = action(data);

              if (typeof result === 'function') {
                result = result(getPartialState(path, globalState), actions);
              }

              if (
                result &&
                  result !== (state = getPartialState(path, globalState)) &&
                  !result.then // !isPromise
              ) {
                scheduleRender(
                  (globalState = setPartialState(
                    path,
                    clone(state, result),
                    globalState
                  ))
                );
              }

              return result;
            };
          })(key, actions[key]) : wireStateToActions(
            path.concat(key),
            (state[key] = clone(state[key])),
            (actions[key] = clone(actions[key]))
          );
        }

        return actions;
      }

      function getKey(node) {
        return node ? node.key : null;
      }

      function eventListener(event) {
        return event.currentTarget.events[event.type](event);
      }

      function updateAttribute(element, name, value, oldValue, isSvg) {
        if (name === 'key') {
        } else if (name === 'style') {
          if (typeof value === 'string') {
            element.style.cssText = value;
          } else {
            if (typeof oldValue === 'string') {
              oldValue = element.style.cssText = '';
            }
            for (const i in clone(oldValue, value)) {
              const style = value == null || value[i] == null ? '' : value[i];
              if (i[0] === '-') {
                element.style.setProperty(i, style);
              } else {
                element.style[i] = style;
              }
            }
          }
        } else {
          if (name[0] === 'o' && name[1] === 'n') {
            name = name.slice(2);

            if (element.events) {
              if (!oldValue) {
                oldValue = element.events[name];
              }
            } else {
              element.events = {};
            }

            element.events[name] = value;

            if (value) {
              if (!oldValue) {
                element.addEventListener(name, eventListener);
              }
            } else {
              element.removeEventListener(name, eventListener);
            }
          } else if (
            name in element &&
          name !== 'list' &&
          name !== 'type' &&
          name !== 'draggable' &&
          name !== 'spellcheck' &&
          name !== 'translate' &&
          !isSvg
          ) {
            element[name] = value == null ? '' : value;
          } else if (value != null && value !== false) {
            element.setAttribute(name, value);
          }

          if (value == null || value === false) {
            element.removeAttribute(name);
          }
        }
      }

      function createElement(node, isSvg) {
        const element =
        typeof node === 'string' || typeof node === 'number'
          ? document.createTextNode(node)
          : (isSvg = isSvg || node.nodeName === 'svg')
            ? document.createElementNS(
              'http://www.w3.org/2000/svg',
              node.nodeName
            )
            : document.createElement(node.nodeName);

        const attributes = node.attributes;
        if (attributes) {
          if (attributes.oncreate) {
            lifecycle.push(() => {
              attributes.oncreate(element);
            });
          }

          for (let i = 0; i < node.children.length; i++) {
            element.appendChild(
              createElement(
                (node.children[i] = resolveNode(node.children[i])),
                isSvg
              )
            );
          }

          for (const name in attributes) {
            updateAttribute(element, name, attributes[name], null, isSvg);
          }
        }

        return element;
      }

      function updateElement(element, oldAttributes, attributes, isSvg) {
        for (const name in clone(oldAttributes, attributes)) {
          if (
            attributes[name] !==
          (name === 'value' || name === 'checked'
            ? element[name]
            : oldAttributes[name])
          ) {
            updateAttribute(
              element,
              name,
              attributes[name],
              oldAttributes[name],
              isSvg
            );
          }
        }

        const cb = isRecycling ? attributes.oncreate : attributes.onupdate;
        if (cb) {
          lifecycle.push(() => {
            cb(element, oldAttributes);
          });
        }
      }

      function removeChildren(element, node) {
        const attributes = node.attributes;
        if (attributes) {
          for (let i = 0; i < node.children.length; i++) {
            removeChildren(element.childNodes[i], node.children[i]);
          }

          if (attributes.ondestroy) {
            attributes.ondestroy(element);
          }
        }
        return element;
      }

      function removeElement(parent, element, node) {
        function done() {
          parent.removeChild(removeChildren(element, node));
        }

        const cb = node.attributes && node.attributes.onremove;
        if (cb) {
          cb(element, done);
        } else {
          done();
        }
      }

      function patch(parent, element, oldNode, node, isSvg) {
        if (node === oldNode) {
        } else if (oldNode == null || oldNode.nodeName !== node.nodeName) {
          const newElement = createElement(node, isSvg);
          parent.insertBefore(newElement, element);

          if (oldNode != null) {
            removeElement(parent, element, oldNode);
          }

          element = newElement;
        } else if (oldNode.nodeName == null) {
          element.nodeValue = node;
        } else {
          updateElement(
            element,
            oldNode.attributes,
            node.attributes,
            (isSvg = isSvg || node.nodeName === 'svg')
          );

          const oldKeyed = {};
          const newKeyed = {};
          const oldElements = [];
          const oldChildren = oldNode.children;
          const children = node.children;

          for (var i = 0; i < oldChildren.length; i++) {
            oldElements[i] = element.childNodes[i];

            var oldKey = getKey(oldChildren[i]);
            if (oldKey != null) {
              oldKeyed[oldKey] = [oldElements[i], oldChildren[i]];
            }
          }

          var i = 0;
          let k = 0;

          while (k < children.length) {
            var oldKey = getKey(oldChildren[i]);
            const newKey = getKey((children[k] = resolveNode(children[k])));

            if (newKeyed[oldKey]) {
              i++;
              continue;
            }

            if (newKey != null && newKey === getKey(oldChildren[i + 1])) {
              if (oldKey == null) {
                removeElement(element, oldElements[i], oldChildren[i]);
              }
              i++;
              continue;
            }

            if (newKey == null || isRecycling) {
              if (oldKey == null) {
                patch(element, oldElements[i], oldChildren[i], children[k], isSvg);
                k++;
              }
              i++;
            } else {
              const keyedNode = oldKeyed[newKey] || [];

              if (oldKey === newKey) {
                patch(element, keyedNode[0], keyedNode[1], children[k], isSvg);
                i++;
              } else if (keyedNode[0]) {
                patch(
                  element,
                  element.insertBefore(keyedNode[0], oldElements[i]),
                  keyedNode[1],
                  children[k],
                  isSvg
                );
              } else {
                patch(element, oldElements[i], null, children[k], isSvg);
              }

              newKeyed[newKey] = children[k];
              k++;
            }
          }

          while (i < oldChildren.length) {
            if (getKey(oldChildren[i]) == null) {
              removeElement(element, oldElements[i], oldChildren[i]);
            }
            i++;
          }

          for (var i in oldKeyed) {
            if (!newKeyed[i]) {
              removeElement(element, oldKeyed[i][0], oldKeyed[i][1]);
            }
          }
        }
        return element;
      }
    }


  /***/
  })

}]);
// # sourceMappingURL=vendors-node_modules_async-dependency-graph_dist_library_js-node_modules_css-mediaquery_index-24451a.js.map
